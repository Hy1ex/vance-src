//====== Copyright ? 1996-2004, Valve Corporation, All rights reserved. =======
//
// Purpose: 
//
//=============================================================================

//	STATIC: "NORMALMAP"				"0..1"
//  STATIC: "WORLDVERTEXTRANSITION" "0..1"
//  STATIC: "SEAMLESS"				"0..1"
//  STATIC: "DETAIL"				"0..1"
//	STATIC: "PHONG"					"0..1"
//  STATIC: "BASETEXTURETRANSFORM2"	"0..1"

//  SKIP: $BASETEXTURETRANSFORM2 && !$WORLDVERTEXTRANSITION
//  SKIP: $BASETEXTURETRANSFORM2 && $SEAMLESS
//  SKIP: $BASETEXTURETRANSFORM2 && $PHONG

#include "common_vs_fxc.h"

const float3 g_FlashlightPos							: register( SHADER_SPECIFIC_CONST_0 );
const float4x4 g_FlashlightWorldToTexture				: register( SHADER_SPECIFIC_CONST_1 );
const float4 g_FlashlightAttenuationFactors				: register( SHADER_SPECIFIC_CONST_5 );

#if SEAMLESS
const float4 SeamlessScale : register( SHADER_SPECIFIC_CONST_6 );
#define SEAMLESS_SCALE (SeamlessScale.x)
#endif
const float4 cBaseTexCoordTransform[2]					:  register( SHADER_SPECIFIC_CONST_6 );
const float4 cNormalMapOrDetailTexCoordTransform[2]		:  register( SHADER_SPECIFIC_CONST_8 );
#if PHONG
const float3 g_EyePos									:  register( SHADER_SPECIFIC_CONST_10 );
#elif BASETEXTURETRANSFORM2
const float4 cBaseTexCoordTransform2[2]					:  register( SHADER_SPECIFIC_CONST_10 ); // Blixibon - Support for $basetexturetransform2
#endif

struct VS_INPUT
{
	float3 vPos							: POSITION; //This HAS to match lightmappedgeneric_vs20.fxc's position input. Otherwise depth fighting errors occur on the 360
	float4 vNormal						: NORMAL;
	float2 vBaseTexCoord				: TEXCOORD0;
#if WORLDVERTEXTRANSITION
	float2 vLightmapTexCoord			: TEXCOORD1;
	float4 vColor						: COLOR0;
#endif
#if NORMALMAP
	float3 vTangentS					: TANGENT;
	float3 vTangentT					: BINORMAL;
#endif
};

struct VS_OUTPUT
{
    float4 projPos					: POSITION;

	float4 spotTexCoord				: TEXCOORD0;

#if SEAMLESS
	float3 SeamlessTexCoord			: TEXCOORD1;
#else
#if BASETEXTURETRANSFORM2
	// Blixibon - Using two extra floats for $basetexturetransform2
	float4 baseTexCoord				: TEXCOORD1;
#else
	float2 baseTexCoord				: TEXCOORD1;
#endif
#endif

#if NORMALMAP
#if PHONG
	float4 tangentPosToLightVector	: TEXCOORD2;
	float4 normalMapTexCoord		: TEXCOORD3;
#else
	float3 tangentPosToLightVector	: TEXCOORD2;
	float2 normalMapTexCoord		: TEXCOORD3;
#endif
#else
	float3 worldPosToLightVector	: TEXCOORD2;
	float3 normal					: TEXCOORD3;
#endif

	float2 detailCoords				: TEXCOORD4;
	float4 worldPos_worldTransition	: TEXCOORD5;	
	float3 vProjPos					: TEXCOORD6;

#if ( SEAMLESS )
	float3 NormalSqr				: TEXCOORD7;
#endif
};

float RemapValClamped( float val, float A, float B, float C, float D)
{
	float cVal = (val - A) / (B - A);
	cVal = saturate( cVal );

	return C + (D - C) * cVal;
}


VS_OUTPUT main( const VS_INPUT v )
{
	VS_OUTPUT o;

	float3 vObjNormal;
	DecompressVertex_Normal( v.vNormal, vObjNormal );

	float4 projPos;
	float3 worldPos;
	float3 worldNormal;
	float3 eyeVector;

	//Projection math HAS to match lightmappedgeneric_vs20.fxc's math exactly. Otherwise depth fighting errors occur on the 360
	projPos = mul( float4( v.vPos, 1 ), cModelViewProj );
	o.projPos = projPos;
	o.vProjPos.xyz = projPos.xyw;

	worldPos = mul( float4( v.vPos, 1 ), cModel[0] );
	worldNormal = mul( vObjNormal, ( float3x3 )cModel[0] );
	
	o.worldPos_worldTransition = float4( worldPos.xyz, 1.0f );

#if NORMALMAP
	float3 worldTangentS = mul( v.vTangentS, cModel[0] );
	float3 worldTangentT = mul( v.vTangentT, cModel[0] );
#endif
#if SEAMLESS
	float3 vNormal=normalize( worldNormal );
	o.NormalSqr = vNormal * vNormal;           // sums to 1.
	o.SeamlessTexCoord = SEAMLESS_SCALE*worldPos;

	// Generate new tangent and binormal with seamless projection
	#if NORMALMAP
		// Optimized version - This must match the projection in the pixel shader!
		worldTangentS.xyz = normalize( float3( o.NormalSqr.y + o.NormalSqr.z, 0.0f, o.NormalSqr.x ) );
		worldTangentT.xyz = normalize( float3( 0.0f, o.NormalSqr.x + o.NormalSqr.z, o.NormalSqr.y ) );
	#endif
#else
#if (SEAMLESS == 0 )
	o.baseTexCoord.x = dot( v.vBaseTexCoord, cBaseTexCoordTransform[0] ) + cBaseTexCoordTransform[0].w;
	o.baseTexCoord.y = dot( v.vBaseTexCoord, cBaseTexCoordTransform[1] ) + cBaseTexCoordTransform[1].w;
#if BASETEXTURETRANSFORM2
	o.baseTexCoord.w = dot( v.vBaseTexCoord, cBaseTexCoordTransform2[0] ) + cBaseTexCoordTransform2[0].w;
	o.baseTexCoord.z = dot( v.vBaseTexCoord, cBaseTexCoordTransform2[1] ) + cBaseTexCoordTransform2[1].w;
#endif
#endif
#endif

	float4 spotTexCoord = mul( float4( worldPos, 1.0f ), g_FlashlightWorldToTexture );
	o.spotTexCoord = spotTexCoord.xyzw;

	float3 worldPosToLightVector = g_FlashlightPos - worldPos;
#if NORMALMAP

#if (DETAIL == 0)
	o.normalMapTexCoord.x = dot( v.vBaseTexCoord, cNormalMapOrDetailTexCoordTransform[0] ) + cNormalMapOrDetailTexCoordTransform[0].w;
	o.normalMapTexCoord.y = dot( v.vBaseTexCoord, cNormalMapOrDetailTexCoordTransform[1] ) + cNormalMapOrDetailTexCoordTransform[1].w;
#else

#if SEAMLESS
	o.normalMapTexCoord.xy = v.vBaseTexCoord;
#else
	o.normalMapTexCoord.xy = o.baseTexCoord.xy; // Blixibon - Had to change this to .xy because BASETEXTURETRANSFORM2 makes this float4
#endif

#endif

	o.tangentPosToLightVector.x = dot( worldPosToLightVector, worldTangentS );
	o.tangentPosToLightVector.y = dot( worldPosToLightVector, worldTangentT );
	o.tangentPosToLightVector.z = dot( worldPosToLightVector, worldNormal );

#if PHONG
	float3 worldPosToEyeVector = g_EyePos - worldPos;
	o.tangentPosToLightVector.w = dot( worldPosToEyeVector, worldTangentS );
	o.normalMapTexCoord.z = dot( worldPosToEyeVector, worldTangentT );
	o.normalMapTexCoord.w = dot( worldPosToEyeVector, worldNormal );
#endif

#else
	o.worldPosToLightVector = worldPosToLightVector;
	o.normal = worldNormal;
#endif

#if DETAIL
	o.detailCoords.x = dot( v.vBaseTexCoord, cNormalMapOrDetailTexCoordTransform[0] ) + cNormalMapOrDetailTexCoordTransform[0].w;
	o.detailCoords.y = dot( v.vBaseTexCoord, cNormalMapOrDetailTexCoordTransform[1] ) + cNormalMapOrDetailTexCoordTransform[1].w;
#else
	o.detailCoords = float2(0,0);
#endif

#if WORLDVERTEXTRANSITION
	o.worldPos_worldTransition.w = v.vColor.w;
#endif
	
	return o;
}