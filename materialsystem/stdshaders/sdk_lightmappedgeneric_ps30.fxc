// STATIC: "MASKEDBLENDING"				"0..1"
// STATIC: "BASETEXTURE2"				"0..1"
// STATIC: "DETAILTEXTURE"				"0..1"
// STATIC: "BUMPMAP"					"0..2"
// STATIC: "BUMPMAP2"					"0..1"
// STATIC: "CUBEMAP"					"0..1"
// STATIC: "ENVMAPMASK"					"0..1"
// STATIC: "BASEALPHAENVMAPMASK"		"0..1"
// STATIC: "SELFILLUM"					"0..1"
// STATIC: "NORMALMAPALPHAENVMAPMASK"	"0..1"
// STATIC: "DIFFUSEBUMPMAP"				"0..1"
// STATIC: "BASETEXTURENOENVMAP"		"0..1"
// STATIC: "BASETEXTURE2NOENVMAP"		"0..1"
// STATIC: "WARPLIGHTING"				"0..1"
// STATIC: "FANCY_BLENDING"				"0..1"
// STATIC: "SEAMLESS"					"0..1"
// STATIC: "BUMPMASK"                   "0..1"
// STATIC: "BASETEXTURETRANSFORM2"		"0..1"
// STATIC: "PARALLAXCORRECT"			"0..1"
// DYNAMIC: "FASTPATHENVMAPCONTRAST"	"0..1"
// DYNAMIC: "FASTPATH"					"0..1"
// DYNAMIC: "WRITEWATERFOGTODESTALPHA"	"0..1"
// DYNAMIC: "PIXELFOGTYPE"				"0..1"
// DYNAMIC: "WRITE_DEPTH_TO_DESTALPHA"	"0..1"
//  SKIP: $BUMPMAP2 && $WARPLIGHTING
//  SKIP: $WARPLIGHTING && $DETAILTEXTURE
//	SKIP: $ENVMAPMASK && $BUMPMAP
//	SKIP: $NORMALMAPALPHAENVMAPMASK && $BASEALPHAENVMAPMASK
//	SKIP: $NORMALMAPALPHAENVMAPMASK && $ENVMAPMASK
//	SKIP: $BASEALPHAENVMAPMASK && $ENVMAPMASK
//	SKIP: $BASEALPHAENVMAPMASK && $SELFILLUM
//  SKIP: !$FASTPATH && $FASTPATHENVMAPCONTRAST
//  SKIP: !$FASTPATH && $FASTPATHENVMAPTINT
//  SKIP: !$BUMPMAP && $DIFFUSEBUMPMAP
//	SKIP: !$BUMPMAP && $BUMPMAP2
//	SKIP: !$BUMPMAP2 && $BUMPMASK
//	SKIP: $ENVMAPMASK && $BUMPMAP2
//	SKIP: $BASETEXTURENOENVMAP && ( !$BASETEXTURE2 || !$CUBEMAP )
//	SKIP: $BASETEXTURE2NOENVMAP && ( !$BASETEXTURE2 || !$CUBEMAP )
//	SKIP: $BASEALPHAENVMAPMASK && $BUMPMAP
//  SKIP: $SEAMLESS && $DETAILTEXTURE
//  SKIP: $SEAMLESS && $MASKEDBLENDING
//  SKIP: $BUMPMASK && ( $SEAMLESS || $DETAILTEXTURE || $SELFILLUM || $BASETEXTURENOENVMAP || $BASETEXTURE2 )

// Too many instructions to do this all at once:
//  SKIP: $FANCY_BLENDING && $BUMPMAP && $DETAILTEXTURE

//  SKIP: $BASETEXTURETRANSFORM2 && !$BASETEXTURE2
//  SKIP: $BASETEXTURETRANSFORM2 && $SEAMLESS

//  SKIP: !$FANCY_BLENDING && $MASKEDBLENDING

//  SKIP: $PARALLAXCORRECT && !$CUBEMAP

// debug crap:
// NOSKIP: $DETAILTEXTURE
// NOSKIP: $CUBEMAP
// NOSKIP: $ENVMAPMASK
// NOSKIP: $BASEALPHAENVMAPMASK
// NOSKIP: $SELFILLUM

// SKIP: $WARPLIGHTING
// SKIP: $FASTPATH
// SKIP: $FASTPATHENVMAPCONTRAST
// SKIP: $BASETEXTURETRANSFORM2

// --- VANCE ---
// DYNAMIC: "VANCE_CSM"				"0..1"
// DYNAMIC: "VANCE_CSM_PERF"		"0..2"
// --- !VANCE ---

#define USE_32BIT_LIGHTMAPS_ON_360 //uncomment to use 32bit lightmaps, be sure to keep this in sync with the same #define in materialsystem/cmatlightmaps.cpp

#include "common_ps_fxc.h"
#include "common_flashlight_fxc.h"
#include "common_lightmappedgeneric_fxc.h"
#include "common_lightingpreview_fxc.h"
#if VANCE_CSM == 1
#include "common_deferredshadows_fxc.h"
#endif

#if SEAMLESS
#define USE_FAST_PATH 1
#else
#define USE_FAST_PATH FASTPATH
#endif

const HALF4 g_EnvmapTint : register( c0 );

#if USE_FAST_PATH == 1
	#if FASTPATHENVMAPCONTRAST == 0
		static const HALF3 g_EnvmapContrast = { 0.0f, 0.0f, 0.0f };
	#else
		static const HALF3 g_EnvmapContrast = { 1.0f, 1.0f, 1.0f };
	#endif

	static const HALF3 g_EnvmapSaturation = { 1.0f, 1.0f, 1.0f };
	static const HALF g_FresnelReflection = 1.0f;
	static const HALF g_OneMinusFresnelReflection = 0.0f;
	static const HALF4 g_SelfIllumTint = { 1.0f, 1.0f, 1.0f, 1.0f };

	#if OUTLINE
		const float4 g_OutlineParams : register( c2 );
		#define OUTLINE_MIN_VALUE0 g_OutlineParams.x
		#define OUTLINE_MIN_VALUE1 g_OutlineParams.y
		#define OUTLINE_MAX_VALUE0 g_OutlineParams.z
		#define OUTLINE_MAX_VALUE1 g_OutlineParams.w

		const float4 g_OutlineColor : register( c3 );
		#define OUTLINE_COLOR g_OutlineColor
	#endif

	#if SOFTEDGES
		const float4 g_EdgeSoftnessParms : register( c4 );
		#define SOFT_MASK_MIN g_EdgeSoftnessParms.x
		#define SOFT_MASK_MAX g_EdgeSoftnessParms.y
	#endif
#else

	const HALF3 g_EnvmapContrast 				: register( c2 );
	const HALF3 g_EnvmapSaturation				: register( c3 );
	const HALF4 g_FresnelReflectionReg			: register( c4 );
	#define g_FresnelReflection g_FresnelReflectionReg.a
	#define g_OneMinusFresnelReflection g_FresnelReflectionReg.b
	const HALF4 g_SelfIllumTint					: register( c7 );
#endif

const float4 g_DetailTint_and_BlendFactor	: register( c8 );
#define g_DetailTint (g_DetailTint_and_BlendFactor.rgb)
#define g_DetailBlendFactor (g_DetailTint_and_BlendFactor.w)

const float4 g_EyePos_MinLight				: register( c10 );
#define g_EyePos g_EyePos_MinLight.xyz
#define g_fMinLighting g_EyePos_MinLight.w

const HALF4 g_FogParams						: register( c11 );
const float4 g_TintValuesAndLightmapScale	: register( c12 );

#define g_flAlpha2 g_TintValuesAndLightmapScale.w

const float4 g_FlashlightAttenuationFactors		: register( c13 );
const float3 g_FlashlightPos					: register( c14 );
const float4x4 g_FlashlightWorldToTexture		: register( c15 ); // through c18
const float4 g_ShadowTweaks						: register( c19 );

#if PARALLAXCORRECT
// Parallax cubemaps
const float4 cubemapPos						: register(c21);
const float4x4 obbMatrix					: register(c22); //through c25
#define g_BlendInverted cubemapPos.w
#else
// Blixibon - Hammer apparently has a bug that causes the vertex blend to get swapped.
// Hammer uses a special internal shader to nullify this, but it doesn't work with custom shaders.
// Downfall got around this by swapping around the base textures in the DLL code when drawn by the editor.
// Doing it here in the shader itself allows us to retain other properties, like FANCY_BLENDING.
// TODO: This may be inefficent usage of a constant
const HALF g_BlendInverted					: register(c21);
#endif

const float g_DetailBlendMode				: register( c32 );

sampler BaseTextureSampler		: register( s0 );
sampler LightmapSampler			: register( s1 );
sampler EnvmapSampler			: register( s2 );
#if FANCY_BLENDING
sampler BlendModulationSampler	: register( s3 );
#endif

#if DETAILTEXTURE
sampler DetailSampler			: register( s12 );
#endif

sampler BumpmapSampler			: register( s4 );
#define AlphaMapSampler		BumpmapSampler

#if BUMPMAP2 == 1
sampler BumpmapSampler2			: register( s5 );
#define AlphaMapSampler2		BumpmapSampler2
#else
sampler EnvmapMaskSampler		: register( s5 );
#endif

#if WARPLIGHTING
sampler WarpLightingSampler		: register( s6 );
#endif
sampler BaseTextureSampler2		: register( s7 );

#if BUMPMASK == 1
sampler BumpMaskSampler			: register( s8 );
#define AlphaMaskSampler		BumpMaskSampler
#endif

#if VANCE_CSM == 1
sampler ShadowDepthSampler		: register( s13 ); // CSM Depth

const float4x4 g_CSMWorldToTexture	: register( c33 ); // to 49
const float4 g_CascadeFwd			: register( c49 );
const float4 g_CascadeLight			: register( c50 );
const float4 g_CascadeAmbient		: register( c51 );
const float2 g_CascadeBias			: register( c52 );
const float2 g_CascadeResolution	: register( c53 );
const float4 g_CascadeSize			: register( c54 );
#endif

#if VANCE_CSM == 1
float DoCSM( sampler DepthSampler, const float3 vProjCoords, float vViewDepth, float LdN )
{
	float2 rtSize = g_CascadeResolution; //float2(4096.0f * 4.0f, 4096.0f) * 2.0f;
	float fEpsilonX = 1.0f / rtSize.y;
	float fEpsilonY = 1.0f / rtSize.x;

	#if VANCE_CSM_PERF < 1
	float3 cascade0 = float3( float2( ( vProjCoords.x / 4 ), vProjCoords.y ), vProjCoords.z );
	float3 cascade1 = float3(
		float2( ( vProjCoords.x / 4 ) + ( g_CascadeSize.y - 2 - 1.0f / 8.0f - 0.5 ), vProjCoords.y + ( g_CascadeSize.y - 1 ) / 2 ) /
			g_CascadeSize.y,
		vProjCoords.z );
	#endif
	#if VANCE_CSM_PERF < 2
	float3 cascade2 =
		float3( float2( ( vProjCoords.x / 4 ) + ( g_CascadeSize.z - 3 - 1.0f / 8.0f ), vProjCoords.y + ( g_CascadeSize.z - 1 ) / 2 ) /
					g_CascadeSize.z,
				vProjCoords.z );
	#endif
	float3 cascade3 =
		float3( float2( ( vProjCoords.x / 4 ) + ( g_CascadeSize.w - 4 - 1.0f / 8.0f ), vProjCoords.y + ( g_CascadeSize.w - 1 ) / 2 ) /
					g_CascadeSize.w,
				vProjCoords.z );

	float projMask = 1.0f;
	if ( vViewDepth >= g_CascadeSize.w * g_CascadeSize.x - 100 )
	{
		projMask = 0.0f;
	}

	float4 vShadowTweaks = float4( fEpsilonX, fEpsilonY, 0.0f, 0.0f );
	#if VANCE_CSM_PERF < 1
	float shadowProjDiff0 = 1;
	float3 shadowMapCenter_objDepth0 = cascade0;
	float2 shadowMapCenter0 = shadowMapCenter_objDepth0.xy;
	float objDepth0 = shadowMapCenter_objDepth0.z + g_CascadeBias.y * ( g_CascadeBias.x * LdN ) * shadowProjDiff0;
	float3 vShadowPos0 = float3( shadowMapCenter0, objDepth0 );

	float shadowProjDiff1 = g_CascadeSize.y;
	float3 shadowMapCenter_objDepth1 = cascade1;
	float2 shadowMapCenter1 = shadowMapCenter_objDepth1.xy;
	float objDepth1 = shadowMapCenter_objDepth1.z + g_CascadeBias.y * ( g_CascadeBias.x * LdN ) * shadowProjDiff1;
	float3 vShadowPos1 = float3( shadowMapCenter1, objDepth1 );
	#endif

	#if VANCE_CSM_PERF < 2
	float shadowProjDiff2 = g_CascadeSize.z;
	float3 shadowMapCenter_objDepth2 = cascade2;
	float2 shadowMapCenter2 = shadowMapCenter_objDepth2.xy;
	float objDepth2 = shadowMapCenter_objDepth2.z + g_CascadeBias.y * ( g_CascadeBias.x * LdN ) * shadowProjDiff2;
	float3 vShadowPos2 = float3( shadowMapCenter2, objDepth2 );
	#endif

	float shadowProjDiff3 = g_CascadeSize.w;
	float3 shadowMapCenter_objDepth3 = cascade3;
	float2 shadowMapCenter3 = shadowMapCenter_objDepth3.xy;
	float objDepth3 = shadowMapCenter_objDepth3.z + g_CascadeBias.y * ( g_CascadeBias.x * LdN ) * shadowProjDiff3;
	float3 vShadowPos3 = float3( shadowMapCenter3, objDepth3 );

	float shadow3 = PCF( DepthSampler, rtSize, shadowMapCenter3.xy, objDepth3 );

	#if VANCE_CSM_PERF < 2
	float shadow2 = PCF( DepthSampler, rtSize, shadowMapCenter2.xy, objDepth2 );
	#else
	float shadow2 = shadow3;
	#endif

	#if VANCE_CSM_PERF < 1
	float shadow1 = PCF( DepthSampler, rtSize, shadowMapCenter1.xy, objDepth1 );
	float shadow0 = PCF( DepthSampler, rtSize, shadowMapCenter0.xy, objDepth0 );
	#else
	float shadow1 = shadow2;
	float shadow0 = shadow2;
	#endif

	float shadow01 = lerp( shadow0, shadow1, pow( saturate( vViewDepth / ( g_CascadeSize.x - 6 ) ), 20.0f ) );
	float shadow012 = lerp( shadow01, shadow2, pow( saturate( vViewDepth / ( g_CascadeSize.y * g_CascadeSize.x - 6 ) ), 20.0f ) );
	float shadow0123 = lerp( shadow012, shadow3, pow( saturate( vViewDepth / ( g_CascadeSize.z * g_CascadeSize.x - 6 ) ), 20.0f ) );

	float shadow = shadow0123;

	if ( projMask == 1.0f )
	{
		float smoothCSMMask = pow( saturate( vViewDepth / ( g_CascadeSize.w * g_CascadeSize.x - 100 ) ), 20.0f );
		float shadowFinal = lerp( shadow, 1.0f, smoothCSMMask );
		return shadowFinal;
	}
	else
	{
		return 1.0f;
	}
}

float3 DoCSMLight( in float3 worldPos, in float3 worldNormal, float3 albedo, float ViewZ )
{
	float3 Out;
	float LdN = max( 1.0f - saturate( dot( worldNormal, -g_CascadeFwd.xyz ) ), 0.01 );
	float4 flashlightSpacePosition = mul( float4( worldPos, 1.0f ), g_CSMWorldToTexture );
	float3 vProjCoords = flashlightSpacePosition.xyz / flashlightSpacePosition.w;
	float3 flShadow = DoCSM( ShadowDepthSampler, vProjCoords, ViewZ, LdN );
	float diffuse = dot( worldNormal, -g_CascadeFwd.xyz );
	diffuse = saturate( diffuse );

	Out = albedo * g_CascadeLight.rgb * diffuse * flShadow;
	return Out;
}
#endif

struct PS_INPUT
{
#if SEAMLESS
	float3 SeamlessTexCoord         : TEXCOORD0;            // zy xz
	float4 detailOrBumpAndEnvmapMaskTexCoord : TEXCOORD1;   // envmap mask
#else
#if BASETEXTURETRANSFORM2
	// Blixibon - Using two extra floats for $basetexturetransform2
	HALF4 baseTexCoord				: TEXCOORD0;
#else
	HALF2 baseTexCoord				: TEXCOORD0;
#endif
	// detail textures and bumpmaps are mutually exclusive so that we have enough texcoords.
#if ( RELIEF_MAPPING == 0 )
	HALF4 detailOrBumpAndEnvmapMaskTexCoord	: TEXCOORD1;
#endif
#endif
// CENTROID: TEXCOORD2
	HALF4 lightmapTexCoord1And2		: TEXCOORD2;
// CENTROID: TEXCOORD3
	HALF4 lightmapTexCoord3			: TEXCOORD3;
	HALF4 worldPos_projPosZ			: TEXCOORD4;
	HALF3x3 tangentSpaceTranspose	: TEXCOORD5;
	// tangentSpaceTranspose		: TEXCOORD6
	// tangentSpaceTranspose		: TEXCOORD7
	HALF4 vertexColor				: COLOR;
	float vertexBlend				: COLOR1;

	// Extra iterators on 360, used in flashlight combo
#if defined( _X360 ) && FLASHLIGHT
	float4 flashlightSpacePos		: TEXCOORD8;
	float4 vProjPos					: TEXCOORD9;
#endif
};

#if LIGHTING_PREVIEW == 2
LPREVIEW_PS_OUT main( PS_INPUT i ) : COLOR
#else
HALF4 main( PS_INPUT i ) : COLOR
#endif
{
	bool bBaseTexture2 = BASETEXTURE2 ? true : false;
	bool bDetailTexture = DETAILTEXTURE ? true : false;
	bool bBumpmap = BUMPMAP ? true : false;
	bool bDiffuseBumpmap = DIFFUSEBUMPMAP ? true : false;
	bool bCubemap = CUBEMAP ? true : false;
	bool bEnvmapMask = ENVMAPMASK ? true : false;
	bool bBaseAlphaEnvmapMask = BASEALPHAENVMAPMASK ? true : false;
	bool bSelfIllum = SELFILLUM ? true : false;
	bool bNormalMapAlphaEnvmapMask = NORMALMAPALPHAENVMAPMASK ? true : false;
	bool bBaseTextureNoEnvmap = BASETEXTURENOENVMAP ? true : false;
	bool bBaseTexture2NoEnvmap = BASETEXTURE2NOENVMAP ? true : false;

	float4 baseColor = 0.0f;
	float4 baseColor2 = 0.0f;
	float4 vNormal = float4(0, 0, 1, 1);
	float3 baseTexCoords = float3(0,0,0);

#if SEAMLESS
	baseTexCoords = i.SeamlessTexCoord.xyz;
#else
	baseTexCoords.xy = i.baseTexCoord.xy;
#endif

#if BASETEXTURETRANSFORM2
	// Blixibon - Simpler version of GetBaseTextureAndNormal() that supports $basetexturetransform2
	// (make this its own function in common_lightmappedgeneric_fxc.h if this becomes more widespread)
	// 
	// Also, not sure where else to put this, but we're using an entire BASETEXTURETRANSFORM2 combo
	// because in DX9, $basetexture2 would update from the original $basetexturetransform, so
	// keeping this code separate retains that original behavior.
	baseColor = tex2D( BaseTextureSampler, baseTexCoords.xy );
	baseColor2 = tex2D( BaseTextureSampler2, i.baseTexCoord.wz );
	if ( bBumpmap || bNormalMapAlphaEnvmapMask )
	{
		vNormal  = tex2D( BumpmapSampler, baseTexCoords.xy );
	}
#else
	GetBaseTextureAndNormal( BaseTextureSampler, BaseTextureSampler2, BumpmapSampler, bBaseTexture2, bBumpmap || bNormalMapAlphaEnvmapMask, 
		baseTexCoords, i.vertexColor.rgb, baseColor, baseColor2, vNormal );
#endif

#if BUMPMAP == 1	// not ssbump
	vNormal.xyz = vNormal.xyz * 2.0f - 1.0f;					// make signed if we're not ssbump
#endif

	HALF3 lightmapColor1 = HALF3( 1.0f, 1.0f, 1.0f );
	HALF3 lightmapColor2 = HALF3( 1.0f, 1.0f, 1.0f );
	HALF3 lightmapColor3 = HALF3( 1.0f, 1.0f, 1.0f );
#if LIGHTING_PREVIEW == 0
	if( bBumpmap && bDiffuseBumpmap )
	{
		HALF2 bumpCoord1;
		HALF2 bumpCoord2;
		HALF2 bumpCoord3;
		ComputeBumpedLightmapCoordinates( i.lightmapTexCoord1And2, i.lightmapTexCoord3.xy,
			bumpCoord1, bumpCoord2, bumpCoord3 );
		
		lightmapColor1 = LightMapSample( LightmapSampler, bumpCoord1 );
		lightmapColor2 = LightMapSample( LightmapSampler, bumpCoord2 );
		lightmapColor3 = LightMapSample( LightmapSampler, bumpCoord3 );
	}
	else
	{
		HALF2 bumpCoord1 = ComputeLightmapCoordinates( i.lightmapTexCoord1And2, i.lightmapTexCoord3.xy );
		lightmapColor1 = LightMapSample( LightmapSampler, bumpCoord1 );
	}
#endif

#if ( DETAILTEXTURE == 1 )
	HALF2 detailTexCoord = i.detailOrBumpAndEnvmapMaskTexCoord.xy;
	HALF2 bumpmapTexCoord = i.baseTexCoord.xy;
#elif ( BUMPMASK == 1 )
	HALF2 detailTexCoord = 0.0f;
	HALF2 bumpmapTexCoord = i.detailOrBumpAndEnvmapMaskTexCoord.xy;
	HALF2 bumpmap2TexCoord = i.detailOrBumpAndEnvmapMaskTexCoord.wz;
#else
	HALF2 detailTexCoord = 0.0f;
	HALF2 bumpmapTexCoord = i.detailOrBumpAndEnvmapMaskTexCoord.xy;
#endif

	HALF2 envmapMaskTexCoord = i.detailOrBumpAndEnvmapMaskTexCoord.wz;

	HALF4 detailColor = HALF4( 1.0f, 1.0f, 1.0f, 1.0f );

#if DETAILTEXTURE
	detailColor = float4( g_DetailTint, 1.0f ) * tex2D( DetailSampler, detailTexCoord );
#endif

#if ( OUTLINE || SOFTEDGES )
	float distAlphaMask = baseColor.a;

#   if OUTLINE
	if ( ( distAlphaMask >= OUTLINE_MIN_VALUE0 ) &&
		 ( distAlphaMask <= OUTLINE_MAX_VALUE1 ) )
	{
		float oFactor=1.0;
		if ( distAlphaMask <= OUTLINE_MIN_VALUE1 )
		{
			oFactor=smoothstep( OUTLINE_MIN_VALUE0, OUTLINE_MIN_VALUE1, distAlphaMask );
		}
		else
		{
			oFactor=smoothstep( OUTLINE_MAX_VALUE1, OUTLINE_MAX_VALUE0, distAlphaMask );
		}
		baseColor = lerp( baseColor, OUTLINE_COLOR, oFactor );
	}
#   endif
#   if SOFTEDGES
	baseColor.a *= smoothstep( SOFT_MASK_MAX, SOFT_MASK_MIN, distAlphaMask );
#   else
	baseColor.a *= distAlphaMask >= 0.5;
#   endif
#endif


#if LIGHTING_PREVIEW == 2
	baseColor.xyz=GammaToLinear(baseColor.xyz);
#endif

	float blendedAlpha = baseColor.a;

#if MASKEDBLENDING
	float blendfactor=0.5;
#else
	
	float blendfactor=i.vertexBlend;

	// See g_BlendInverted's declaration for more info on this
	if (g_BlendInverted > 0.0)
	{
		blendfactor=1.0f-blendfactor;
	}

#endif

	if( bBaseTexture2 )
	{
#if (SELFILLUM == 0) && (PIXELFOGTYPE != PIXEL_FOG_TYPE_HEIGHT) && (FANCY_BLENDING)
		float4 modt=tex2D(BlendModulationSampler,baseTexCoords);
#if MASKEDBLENDING
		float minb=modt.g-modt.r;
		float maxb=modt.g+modt.r;
#else
		float minb=max(0,modt.g-modt.r);
		float maxb=min(1,modt.g+modt.r);
#endif
		blendfactor=smoothstep(minb,maxb,blendfactor);
#endif
		baseColor.rgb = lerp( baseColor.rgb, baseColor2.rgb, blendfactor );
		blendedAlpha = lerp( baseColor.a, baseColor2.a, blendfactor );
	}

	HALF3 specularFactor = 1.0f;
	float4 vNormalMask = float4(0, 0, 1, 1);
	if( bBumpmap )
	{
		if( bBaseTextureNoEnvmap )
		{
			vNormal.a = 0.0f;
		}

#if ( BUMPMAP2 == 1 )
		{
	#if ( BUMPMASK == 1 )
			HALF2 b2TexCoord = bumpmap2TexCoord;
	#else
			HALF2 b2TexCoord = bumpmapTexCoord;
	#endif

			HALF4 vNormal2;
			if ( BUMPMAP == 2 )
				vNormal2 = tex2D( BumpmapSampler2, b2TexCoord );
			else
				vNormal2 = DecompressNormal( BumpmapSampler2, b2TexCoord, NORM_DECODE_NONE, AlphaMapSampler2 );		// Bump 2 coords

			if( bBaseTexture2NoEnvmap )
			{
				vNormal2.a = 0.0f;
			}

	#if ( BUMPMASK == 1 )
			float3 vNormal1 = DecompressNormal( BumpmapSampler, i.detailOrBumpAndEnvmapMaskTexCoord.xy, NORM_DECODE_NONE, AlphaMapSampler );

			vNormal.xyz = normalize( vNormal1.xyz + vNormal2.xyz );

			// Third normal map...same coords as base
			vNormalMask = DecompressNormal( BumpMaskSampler, i.baseTexCoord.xy, NORM_DECODE_NONE, AlphaMaskSampler );

			vNormal.xyz = lerp( vNormalMask.xyz, vNormal.xyz, vNormalMask.a );		// Mask out normals from vNormal
			specularFactor = vNormalMask.a;
	#else // BUMPMASK == 0
			if ( FANCY_BLENDING && bNormalMapAlphaEnvmapMask )
			{
				vNormal = lerp( vNormal, vNormal2, blendfactor);
			}
			else
			{
				vNormal.xyz = lerp( vNormal.xyz, vNormal2.xyz, blendfactor);
			}

	#endif

		}

#endif // BUMPMAP2 == 1

		if( bNormalMapAlphaEnvmapMask )
		{
			specularFactor *= vNormal.a;
		}
	}
	else if ( bNormalMapAlphaEnvmapMask )
	{
		specularFactor *= vNormal.a;
	}

#if ( BUMPMAP2 == 0 )
	if( bEnvmapMask )
	{
		specularFactor *= tex2D( EnvmapMaskSampler, envmapMaskTexCoord ).xyz;	
	}
#endif

	if( bBaseAlphaEnvmapMask )
	{
		specularFactor *= 1.0 - blendedAlpha; // Reversing alpha blows!
	}
	float4 albedo = float4( 1.0f, 1.0f, 1.0f, 1.0f );
	float alpha = 1.0f;
	albedo *= baseColor;
	if( !bBaseAlphaEnvmapMask && !bSelfIllum )
	{
		alpha *= blendedAlpha; // Blixibon - Replaced baseColor.a with blendedAlpha
	}

	if( bDetailTexture )
	{
		albedo = TextureCombine( albedo, detailColor, g_DetailBlendMode, g_DetailBlendFactor );
	}

	// The vertex color contains the modulation color + vertex color combined
#if ( SEAMLESS == 0 )
	albedo.xyz *= i.vertexColor.xyz;
#endif
	alpha *= i.vertexColor.a * g_flAlpha2; // not sure about this one

	// Save this off for single-pass flashlight, since we'll still need the SSBump vector, not a real normal
	float3 vSSBumpVector = vNormal.xyz;

	HALF3 diffuseLighting;
	if( bBumpmap && bDiffuseBumpmap )
	{

// ssbump
#if ( BUMPMAP == 2 )
		diffuseLighting = vNormal.x * lightmapColor1 +
						  vNormal.y * lightmapColor2 +
						  vNormal.z * lightmapColor3;
		diffuseLighting *= g_TintValuesAndLightmapScale.rgb;

		// now, calculate vNormal for reflection purposes. if vNormal isn't needed, hopefully
		// the compiler will eliminate these calculations
		vNormal.xyz = normalize( bumpBasis[0]*vNormal.x + bumpBasis[1]*vNormal.y + bumpBasis[2]*vNormal.z);
#else
		float3 dp;
		dp.x = saturate( dot( vNormal.xyz, bumpBasis[0] ) );
		dp.y = saturate( dot( vNormal.xyz, bumpBasis[1] ) );
		dp.z = saturate( dot( vNormal.xyz, bumpBasis[2] ) );
		dp *= dp;
		
		if ( g_DetailBlendMode == TCOMBINE_SSBUMP_BUMP )
		{
			dp *= 2*detailColor;
		}
		diffuseLighting = dp.x * lightmapColor1 +
						  dp.y * lightmapColor2 +
						  dp.z * lightmapColor3;
		float sum = dot( dp, float3( 1.0f, 1.0f, 1.0f ) );
		diffuseLighting *= g_TintValuesAndLightmapScale.rgb / sum;
#endif
	}
	else
	{
		diffuseLighting = lightmapColor1 * g_TintValuesAndLightmapScale.rgb;
	}

#if WARPLIGHTING && ( SEAMLESS == 0 )
	float len=0.5*length(diffuseLighting);
	// FIXME: 8-bit lookup textures like this need a "nice filtering" VTF option, which converts
	//        them to 16-bit on load or does filtering in the shader (since most hardware - 360
	//        included - interpolates 8-bit textures at 8-bit precision, which causes banding)
	diffuseLighting *= 2.0*tex2D(WarpLightingSampler,float2(len,0));
#endif

#if 1 //CUBEMAP || LIGHTING_PREVIEW || ( defined( _X360 ) && FLASHLIGHT )
	float3x3 tangentSpaceTranspose = i.tangentSpaceTranspose;
	
	float3 worldSpaceNormal = mul( vNormal.xyz, i.tangentSpaceTranspose );
#endif

	float3 worldVertToEyeVector = g_EyePos - i.worldPos_projPosZ.xyz;

#if FOGTYPE == 2 || FLASHLIGHT != 0
	float3 diffuseComponent = albedo.xyz * diffuseLighting;
#else
	float3 vEyeDir = normalize( worldVertToEyeVector );
	float flFresnelMinlight = saturate( dot( worldSpaceNormal, vEyeDir ) );

	float3 diffuseComponent = albedo.xyz * lerp( diffuseLighting, 1, g_fMinLighting * flFresnelMinlight );
#endif

	if( bSelfIllum )
	{
		float3 selfIllumComponent = g_SelfIllumTint.xyz * albedo.xyz;
		diffuseComponent = lerp( diffuseComponent, selfIllumComponent, blendedAlpha ); // Blixibon - Replaced baseColor.a with blendedAlpha
	}

	HALF3 specularLighting = HALF3( 0.0f, 0.0f, 0.0f );
#if CUBEMAP
	if( bCubemap )
	{
		//float3 worldVertToEyeVector = g_EyePos - i.worldPos_projPosZ.xyz;
		float3 reflectVect = CalcReflectionVectorUnnormalized( worldSpaceNormal, worldVertToEyeVector );

		// Calc Fresnel factor
		half3 eyeVect = normalize(worldVertToEyeVector);
		HALF fresnel = 1.0 - dot( worldSpaceNormal, eyeVect );
		fresnel = pow( fresnel, 5.0 );
		fresnel = fresnel * g_OneMinusFresnelReflection + g_FresnelReflection;
		
#if PARALLAXCORRECT
		//Parallax correction (2_0b and beyond)
        //Adapted from http://seblagarde.wordpress.com/2012/09/29/image-based-lighting-approaches-and-parallax-corrected-cubemap/
        float3 worldPos = i.worldPos_projPosZ.xyz;
        float3 positionLS = mul(float4(worldPos, 1), obbMatrix);
        float3 rayLS = mul(reflectVect, (float3x3) obbMatrix);

        float3 firstPlaneIntersect = (float3(1.0f, 1.0f, 1.0f) - positionLS) / rayLS;
        float3 secondPlaneIntersect = (-positionLS) / rayLS;
        float3 furthestPlane = max(firstPlaneIntersect, secondPlaneIntersect);
        float distance = min(furthestPlane.x, min(furthestPlane.y, furthestPlane.z));

        // Use distance in WS directly to recover intersection
        float3 intersectPositionWS = worldPos + reflectVect * distance;
        reflectVect = intersectPositionWS - cubemapPos;
#endif
		
		specularLighting = ENV_MAP_SCALE * texCUBE( EnvmapSampler, reflectVect );
		specularLighting *= specularFactor;
								   
		specularLighting *= g_EnvmapTint.rgb;
#if FANCY_BLENDING == 0
		HALF3 specularLightingSquared = specularLighting * specularLighting;
		specularLighting = lerp( specularLighting, specularLightingSquared, g_EnvmapContrast );
		HALF3 greyScale = dot( specularLighting, HALF3( 0.299f, 0.587f, 0.114f ) );
		specularLighting = lerp( greyScale, specularLighting, g_EnvmapSaturation );
#endif
		specularLighting *= fresnel;
	}
#endif

#if VANCE_CSM == 1
	diffuseComponent += DoCSMLight( i.worldPos_projPosZ.xyz, worldSpaceNormal.xyz, baseColor.rgb, length(i.worldPos_projPosZ.xyz - g_EyePos));
#endif
	HALF3 result = diffuseComponent + specularLighting;
	
#if LIGHTING_PREVIEW
	worldSpaceNormal = mul( vNormal, tangentSpaceTranspose );
#	if LIGHTING_PREVIEW == 1
	float dotprod = 0.7+0.25 * dot( worldSpaceNormal, normalize( float3( 1, 2, -.5 ) ) );
	return FinalOutput( HALF4( dotprod*albedo.xyz, alpha ), 0, PIXEL_FOG_TYPE_NONE, TONEMAP_SCALE_NONE );
#	else
	LPREVIEW_PS_OUT ret;
	ret.color = float4( albedo.xyz,alpha );
	ret.normal = float4( worldSpaceNormal,alpha );
	ret.position = float4( i.worldPos_projPosZ.xyz, alpha );
	ret.flags = float4( 1, 1, 1, alpha );

	return FinalOutput( ret, 0, PIXEL_FOG_TYPE_NONE, TONEMAP_SCALE_NONE );	
#	endif
#else // == end LIGHTING_PREVIEW ==

	bool bWriteDepthToAlpha = false;

	bWriteDepthToAlpha = ( WRITE_DEPTH_TO_DESTALPHA != 0 ) && ( WRITEWATERFOGTODESTALPHA == 0 );

	float fogFactor = CalcPixelFogFactor( PIXELFOGTYPE, g_FogParams, g_EyePos.xyz, i.worldPos_projPosZ.xyz, i.worldPos_projPosZ.w );

#if WRITEWATERFOGTODESTALPHA && (PIXELFOGTYPE == PIXEL_FOG_TYPE_HEIGHT)
	alpha = fogFactor;
#endif

	return FinalOutput( float4( result.rgb, alpha ), fogFactor, PIXELFOGTYPE, TONEMAP_SCALE_LINEAR, bWriteDepthToAlpha, i.worldPos_projPosZ.w );

#endif
}
 
